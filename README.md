# coder

就项目中的部分问题答复如下。

## 文件

计算机的存储是通过触发器（具体请学习逻辑电路设计相关知识）实现的。数据在电路中以01序列的方式被记忆与重置。

由于冯诺依曼原理（具体请学习计算机原理相关知识）、总线限制（具体请学习操作系统相关知识）和取址机制（具体请学习计算机架构体系与汇编语言），数据在计算机中只能以字节为单位进行操作，也就是8个01位。

数据只是一段01序列而没有特定的其他含义。我们人为地将数据划分为一系列文件（可以了解一下Linux的split指令）（具体如何划分、识别、管理这些数据，请学习文件系统和磁盘读写相关知识）。

文件分为二进制文件和文本文件。文件类型与文件后缀名无关，而取决于文件中数据的结构。文件类型的识别与文件后缀名无关，而取决于文件头的Magic Number和元数据。具体内容自行搜索。

也许你要问了，那后缀名有什么用，岂不是可有可无？答曰，它决定了打开它使用的默认程序，也决定了Windows文件资源管理器对它文件类型的（至少两成都是错误的，如果你玩游戏，那么五成都是错误的）判断。

二进制文件指文本文件以外的其他文件，有时也认为文本文件是一种特殊的二进制文件。文本文件指使用了特定字符编码的文件。所谓字符编码，就是字符集中的字符与若干字节的01序列之间的一种映射关系。

比如ASCII编码，其字符集被称为ASCII字符集，是单个字符与单个字节之间的映射。比如ASCII这五个字母，实际上存储为:

0100 0001 0101 0011 0100 0011 0100 1001 0100 1001

其中，每八个01位对应一个字母。

一种常用的编码是ANSI,该编码严格来讲不是一种编码，而是两种编码的组合，是基于ASCII与另一种编码，具体取决于你的区域和语言设置。

对于简体中文，ANSI是ASCII与GB2312的组合。在这种编码中，一个汉字或中文标点符号是两个字节，一个英文字母或ASCII里的其他符号是一个字节。

中文的字符很多，两个字节不够，为此，我们有GB18030。在这种编码中，一个汉字是两个或四个字节。有兴趣的还可以了解一下GBK。

另一种常用编码是UTF-8，该编码基于字符集Unicode的一个子集，涵盖了常见的语言和特殊字符。在这种编码中，一个字符是1~4个字节，其中汉字是两个、三个或四个字节。

我们平时使用的常用汉字，一般都是用两个字节存储。少数生僻字是三个四个字节。在Windows系统中，文本文件的编码方式（大多数时候）会作为元数据放在文件头中。

## Huffman编码

### 答语言、字体、段落格式、文件类型问题

Huffman编码不是一种特定的字符编码。严格来讲，它是把字节映射为不定长度01串的编码。

对于ASCII这类字符编码，它们的单个数据长度总是确定的若干个字节，但Huffman编码的结果可能是7个01位。

对于ASCII这类字符编码，它们的单个数据是一个字符，而Huffman编码的单个数据是一个字节：它不关心文本文件的编码方式。

对Huffman编码来讲，不管你是文本文件、图片文件还是二进制文件，我总可以把你的数据看成二进制格式的、一个字节一个字节的01串。如果你有7个01位，那我在末尾补个0凑成一个字节就可以了。

比如一个汉字，我不关心它如何编码，它总归是几个字节，我对每个字节分别编码就可以了。至于解码后如何识别，既然编码前能识别，解码后当然也能识别，它们的文件可是一模一样的。

而一个字节有多少种变化呢？只有256种。所以Huffman树最多有256个叶子节点。所以不用考虑那么多语言、字体、段落格式、文件类型，归根结底都是字节。

### 答动态哈夫曼（Adaptive Huffman）实时变化编码问题

关于Huffman树和AH的原理，参考我在main.cpp里给出的网址，该网址用动画的形式准确而细致地讲清楚了。

有同学提出，AH交换节点时其子节点的编码都变了，他认为这是不合理的。但这恰是AH的精髓所在。

编码时，边读取数据边编码。解码时，边读取编码边解码。哈夫曼树是动态的。

编码时，一个字节比如 0000 0000，我在读到它的时候它有一个原本的编码，我把这个编码输出，随后调整我的AH树，从对应叶子节点向上更新。它后续的编码，以及其他诸多字节后续的编码，都改变了。

解码时，我读到了这个编码，于是我调整我的AH树，从这个编码对应的叶子节点向上更新。它的编码，以及其他诸多字节后续的编码，都改变了。

但我可以确保，解码时的AH树，此时此刻，与当时编码到此处时的AH树，形态完全相同，所以它们对诸多字节后续的编码也都完全相同。这两颗AH树，虽然谁都没说，但心有灵犀地换了密码。我觉得这很美。

该同学把原因归于交换节点，虽然他的那个结论是对的，但与我们目前讨论的问题其实没有关系。

### 答AH交换节点问题

接下来讨论该同学的结论。他认为能交换的两个节点中，至少有一个是叶子节点，但他没有给出证明。我有一个粗略的证明。

鉴于Huffman树的奇特结构，说它是树，不如说它是一条链。这是因为，Huffman树的每一层，恰有一个叶子节点（除了根那一层，除了NYT节点）和一个内节点（即合成的、不对应字符的节点）。

由此得出，对于一个内节点x,如果y不是它的直系祖先（即爸爸的爸爸、爷爷的爷爷之类），且不是它的后代（即儿子的儿子，孙子的孙子之类），则y必然是叶子节点。

这是因为除了x的子树，再没有比x更深的节点；而x的直系祖先又恰好是每一层唯一的那个内节点，由此y只能是叶子节点。

而一个节点无论如何不能和它的直系祖先与后代交换，否则树就不成为树，而成为森林。故此，能交换的两个节点中，至少有一个是叶子节点。

## C++文件读写

既然要把文件看成一个字节一个字节的01串处理，C++文件读写就应该使用char数组。注意char不是字符类型，而是单字节类型。这一个字节用来放什么，无所谓。

具体就是使用ifstream里定义的read函数。参见我的main.cpp里给出的微软网址链接。

应当说明，我的使用是不规范的。规范的写法应该验证文件路径是否存在，流是否异常等。

### 答Windows换行符比Linux多了一个`\r`的问题

如果你采用流运算符读入，比如 `fin >> ch;` ， 或者你一行一行读入，比如 `gets(str);` 那的确可能遇到这类问题。因为这类读入总是需要一个终止条件，读到空格停止、读到换行停止之类。

我们其实可以换种方法读，比如，终止条件设定为每次读128个字节怎么样？那么对于你来说，多出的`\r`也不过就是一个可编码的字节罢了。

### 一些其他问题

有兴趣的同学，可以自行了解大小端问题、size_t问题。

我的代码没有处理大小端问题。应当指出，我对size_t的处理不规范，这是因为size_t类型的很多隐式转换没有被定义，而我忽视了这一点。

如果有同学使用我的代码遇到相关的报错，尝试在该类型的变量前加上`(unsigned long)`或`(int)`。
